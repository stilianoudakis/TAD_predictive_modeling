---
title: "Visualizing Example of Clustered Predicted TAD Boundary Regions"
author: "Spiro Stilianoudakis"
date: "August 9, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Loading Libraries

```{r}
library(GenomicRanges)
library(caret)
library(data.table)
library(gbm)
library(randomForest)
library(glmnet)
library(pROC)
library(plyr)
library(dplyr)
library(ggplot2)
library(DMwR)
library(gridExtra)
library(pROC)
library(ROCR)
#library(leaps)
library(cluster)
library(scales)
library(GGally)
library(network)
library(sna)
library(gtable)
library(grid)
library(magrittr) 
library(DT)
library(tidyverse)
library(reshape)
library(ROSE)
library(lattice)
library(corrplot)
library(cluster)
library(RColorBrewer)
library(GenometriCorr)
library(ggpubr)
library(ggsignif)
library(Vennerable)
library(VennDiagram)
library(ChIPpeakAnno)
library(EnrichedHeatmap)
library(factoextra)
library(dendextend)
```

# Steps
##1.	Build chromosome specific test data
###a.	Bin chromosome specific data at bp resolution (i.e. 1 row -> 1 bp)
###b.	Annotate data matrix with distances to top TFBS
##2.	Validate best performing model on test data
##3.	Extract probability vector
##4.	Determine threshold for identifying predicted TAD boundary
###a.	Consider the base pairs where the probability vector is given to be 1 
###b.	Consider the midpoints of all groups of base pairs with probability 1
###c.	Obtain distance matrix of all pairwise distances between midpoints
###d.	Perform PAM clustering on the distance matrix
###i.	Obtain optimal number of clusters using silhouette method
###e.	Assign predicted TAD boundary as the new midpoint (bp) of clustered distances

# GM12878

## CHR 22

###17380000-18650000 (first 10 called TAD boundaries)

```{r}
#GM12878
#CHR22

#reading in probability vector
pred.TADModel <- readRDS("Z:/TAD_data_analysis/GM12878/10kb/results_by_chr/CHR22/smote/distance/enet/pred.TADModel.rds")

#reading in called and predicted TAD boundary regions
called_and_pred <- readRDS(paste0("Z:/TAD_data_analysis/GM12878/10kb/results_by_chr/CHR22/smote/distance/enet/called_and_pred_bounds.rds"))

#assigning called tad boundaries
called <- called_and_pred[[1]]
called <- resize(called, width=1,fix = "center")

#assigning predicted tad boundaries
predicted <- called_and_pred[[2]]

#reading in base pair data for chromosome 22
seqData <- readRDS("Z:/TAD_data_analysis/seq_data/seqData_CHR22.rds")

#creating a dataframe with base pair coordinates, what the probability of each base pair being a TAD boundary, and which base pair corresponds to a called tad boundary
predprobdata <- data.frame(basenum = seqData,
                           prob = pred.TADModel,
                           called = ifelse(seqData %in% start(called), "Yes", "No"))
dim(predprobdata) #48284564        4

rm(seqData)
rm(pred.TADModel)
rm(called_and_pred)

start(called)[1:10]
#17389999 17539999 17549999 17649999 17819999 18009999 18029999 18209999 18279999 18639999

#creating a window from the first called tad boundary to the 10th called tad boundary (+- 10000 bp)
s=start(called)[1:10][1]-10000+1
e=start(called)[1:10][10]+10000+1

predprobdata2 <- predprobdata[which(predprobdata$basenum>=s & predprobdata$basenum <= e), ]
dim(predprobdata2) #1270001       3

#datasets for plotting
##only called boundaries
calleddata <- predprobdata2[which(predprobdata2$called=="Yes"),]
dim(calleddata) #10  3
##only predicted tad regions (p=1)
predicteddata <- predprobdata2[which(predprobdata2$prob==1),]
dim(predicteddata) #20055     3

#plot
ggplot() + 
  geom_line(data=predprobdata2, aes(x=basenum, y=prob), 
            color='black',
            size=.5)+
  geom_vline(data=calleddata, aes(xintercept=basenum, 
                            color="blue"),
             size=.75,
             show.legend = TRUE)+
  geom_vline(data=predicteddata, aes(xintercept=basenum, 
                                  color="red"),
             size=.75,
             show.legend = TRUE)+
  xlab("Base Pair") +
  ylab("Predicted Probability") +
  scale_color_manual(name = '', 
                     values =c("blue", "red"),
                     labels = c("Called Boundary", 'Predicted Region'))+
  theme_minimal() +
  theme_bw() +
  theme(axis.text.x = element_text(size=15),
        axis.text.y = element_text(size = 15),
        axis.title.x = element_text(size = 20),
        axis.title.y = element_text(size = 20),
        #strip.text.x = element_text(size = 15),
        #panel.spacing = unit(2, "lines"),
        legend.text=element_text(size=15),
        legend.title=element_text(size=20),
        plot.title = element_text(size=20),
        legend.position = "bottom")

#determine midpoints of predicted tad regions
prob1basenumdiff <- diff(predicteddata$basenum)
retain <- numeric()
x <- 1
for(i in 1:length(prob1basenumdiff)){
  if(prob1basenumdiff[i]<=1){retain[i] = x}else{x = x+1; retain[i] = x}
}
retain = c(1,retain)
length(table(retain)) #95

mid <- numeric()
for(i in unique(retain)){
  #print(i)
  bpdat <- predicteddata$basenum[which(retain==i)]
  n=length(bpdat)
  mid[i] <- ceiling((bpdat[1]+bpdat[n])/2)
}

#create distance matrix of all pairwise distances between midpoints
x <- dist(mid, method = "euclidean")

#visualize distance matrix
fviz_dist(x, gradient = list(low = "white", mid = "pink", high = muted("red")))+
  xlab("Predicted Boundary Regions")+
  ylab("Predicted Boundary Regions")+
  #scale_fill_continuous("Distance")+
  scale_fill_gradient2("Distance\nBetween\nMidpoints",
                       low = "white", 
                       mid = "pink",
                       midpoint = 600000,
                       high = muted("red"),
                       limits=c(0,1200000),
                       breaks=c(0,400000, 800000, 1200000),
                       labels=c("0","400000", "800000", "1200000"))+
  #scale_x_discrete(labels=xlabels)+
  #scale_y_discrete(labels=xlabels)+
  theme_minimal()+
  theme(axis.text.x = element_text(size = 5),
        axis.text.y = element_text(size = 5),
        axis.title.x = element_text(size = 20),
        axis.title.y = element_text(size = 20),
        #panel.grid.major = element_blank(),
        #panel.grid.minor = element_blank(),
        #strip.text.x = element_text(size = 15),
        #panel.spacing = unit(2, "lines"),
        legend.text=element_text(size=15),
        legend.title=element_text(size=20),
        plot.title = element_text(size=20))

#cluster distance matrix
hc1 <- hclust(x, method = "complete")
plot(hc1)

#determine suitable number of clusters using the silhouette method
z <- sapply(2:(length(mid)-1), function(i) { 
  mean(silhouette(cutree(hc1, i), dist=x)[,"sil_width"]) })
k=which.max(z)+1
k #10

#perform PAM clustering to determine cluster centers
c <- clara(mid, 
           k=k, 
           samples=100,
           metric = "euclidean",
           stand = FALSE, 
           trace = 2, 
           medoids.x = TRUE)
clustdf <- data.frame(mid=mid, 
                      clust=c$clustering, 
                      medoid=ifelse(mid %in% c$medoids, "Yes", "No"))

dend <- as.dendrogram(hc1)
dend %>% set("labels_colors", 
             value=as.numeric(clustdf$medoid)+1) %>% 
  set("labels_cex", value=1.5) %>% 
  plot(main = "Clustered Distances", xlab="Predicted Boundary Regions")
rect.hclust(hc1, k = k)

#assign cluster centers as predicted TAD boundaries
predprobdata2$predicted <- ifelse(predprobdata2$basenum %in% clustdf$mid[which(clustdf$medoid=="Yes")], "Yes", "No")

predicteddata2 <- predprobdata2[which(predprobdata2$predicted=="Yes"),]

ggplot() + 
  geom_line(data=predprobdata2, aes(x=basenum, y=prob), 
            color='black',
            size=.5)+
  geom_vline(data=calleddata, aes(xintercept=basenum, 
                                  color="blue"),
             size=.75,
             show.legend = TRUE)+
  geom_vline(data=predicteddata, aes(xintercept=basenum, 
                                     color="red"),
             size=.75,
             show.legend = TRUE)+
  geom_vline(data=predicteddata2, aes(xintercept=basenum, 
                                     color="green"),
             size=.75,
             show.legend = TRUE)+
  xlab("Base Pair") +
  ylab("Predicted Probability") +
  scale_color_manual(name = '', 
                     values =c("blue", "green", "red"),
                     labels = c("Called Boundary",
                                "Predicted Boundary",
                                "Predicted Region"))+
  theme_minimal() +
  theme_bw() +
  theme(axis.text.x = element_text(size=15),
        axis.text.y = element_text(size = 15),
        axis.title.x = element_text(size = 20),
        axis.title.y = element_text(size = 20),
        #strip.text.x = element_text(size = 15),
        #panel.spacing = unit(2, "lines"),
        legend.text=element_text(size=15),
        legend.title=element_text(size=20),
        plot.title = element_text(size=20),
        legend.position = "bottom")

  
```

# GM12878

## CHR22

### 17390000-18640000 (first called TAD on chr 22; 2 boundaries)

```{r}
domains <- read.table("Z:/TAD_data_analysis/GM12878/10kb/GM12878_domain_data_10000.b.txt", header=F)
resolution=as.integer(10000)
preprocess=TRUE
domains.mat=domains
domains.mat <- domains.mat[,1:3]
domains.mat[,1] <- paste0("chr",domains.mat[,1])
colnames(domains.mat) <- c("Chromosome", "Start", "End")
if(preprocess==TRUE){
  ##restricting domain data to TADs > 2*resolution and < 2,000,000
  domains.mat <- domains.mat[which((domains.mat$End - domains.mat$Start)>(2*resolution) & (domains.mat$End - domains.mat$Start)<2000000),]
}

head(domains.mat[which(domains.mat$Chromosome=="chr22"),])
d <- domains.mat[which(domains.mat$Chromosome=="chr22"),]
head(d[order(d$Start, decreasing = FALSE),])
d <- d[order(d$Start, decreasing = FALSE),]

s=d$Start[1]-1000
e=d$End[2]+1000
predprobdata2 <- predprobdata[which(predprobdata$basenum>=s & predprobdata$basenum <= e), ]
dim(predprobdata2) #152001      3

calleddata <- predprobdata2[which(predprobdata2$called=="Yes"),]
dim(calleddata) #2 3

predicteddata <- predprobdata2[which(predprobdata2$prob==1),]
dim(predicteddata) #3471    3

ggplot() + 
  geom_line(data=predprobdata2, aes(x=basenum, y=prob), 
            color='black',
            size=.5)+
  geom_vline(data=calleddata, aes(xintercept=basenum, 
                                  color="blue"),
             size=.75,
             show.legend = TRUE)+
  geom_vline(data=predicteddata, aes(xintercept=basenum, 
                                     color="red"),
             size=.75,
             show.legend = TRUE)+
  xlab("Base Pair") +
  ylab("Predicted Probability") +
  scale_color_manual(name = '', 
                     values =c("blue", "red"),
                     labels = c("Called Boundary", 'Predicted Region'))+
  theme_minimal() +
  theme_bw() +
  theme(axis.text.x = element_text(size=15),
        axis.text.y = element_text(size = 15),
        axis.title.x = element_text(size = 20),
        axis.title.y = element_text(size = 20),
        #strip.text.x = element_text(size = 15),
        #panel.spacing = unit(2, "lines"),
        legend.text=element_text(size=15),
        legend.title=element_text(size=20),
        plot.title = element_text(size=20),
        legend.position = "bottom")


prob1basenumdiff <- diff(predicteddata$basenum)
retain <- numeric()
x <- 1
for(i in 1:length(prob1basenumdiff)){
  if(prob1basenumdiff[i]<=1){retain[i] = x}else{x = x+1; retain[i] = x}
}
retain = c(1,retain)
length(table(retain)) #20

mid <- numeric()
for(i in unique(retain)){
  #print(i)
  bpdat <- predicteddata$basenum[which(retain==i)]
  n=length(bpdat)
  mid[i] <- ceiling((bpdat[1]+bpdat[n])/2)
}

x <- dist(mid, method = "euclidean")

fviz_dist(x, gradient = list(low = "white", mid = "pink", high = muted("red")))+
  xlab("Predicted Boundary Regions")+
  ylab("Predicted Boundary Regions")+
  #scale_fill_continuous("Distance")+
  scale_fill_gradient2("Distance\nBetween\nMidpoints",
                       low = "white", 
                       mid = "pink",
                       midpoint = 75000,
                       high = muted("red"),
                       limits=c(0,150000),
                       breaks=c(0,50000,100000,150000),
                       labels=c("0","50000", "100000", "150000"))+
  #scale_x_discrete(labels=xlabels)+
  #scale_y_discrete(labels=xlabels)+
  theme_minimal()+
  theme(axis.text.x = element_text(size = 15),
        axis.text.y = element_text(size = 15),
        axis.title.x = element_text(size = 20),
        axis.title.y = element_text(size = 20),
        #panel.grid.major = element_blank(),
        #panel.grid.minor = element_blank(),
        #strip.text.x = element_text(size = 15),
        #panel.spacing = unit(2, "lines"),
        legend.text=element_text(size=15),
        legend.title=element_text(size=20),
        plot.title = element_text(size=20))


hc1 <- hclust(x, method = "complete")
plot(hc1)
z <- sapply(2:(length(mid)-1), function(i) { 
  mean(silhouette(cutree(hc1, i), dist=x)[,"sil_width"]) })
k=which.max(z)+1
k #2

c <- clara(mid, 
           k=k, 
           samples=100,
           metric = "euclidean",
           stand = FALSE, 
           trace = 2, 
           medoids.x = TRUE)
clustdf <- data.frame(mid=mid, 
                      clust=c$clustering, 
                      medoid=ifelse(mid %in% c$medoids, "Yes", "No"))

dend <- as.dendrogram(hc1)
dend %>% set("labels_colors", 
             value=as.numeric(clustdf$medoid)+1) %>% 
  set("labels_cex", value=1.5) %>% 
  plot(main = "Clustered Distances", xlab="Predicted Boundary Regions")
rect.hclust(hc1, k = k)


predprobdata2$predicted <- ifelse(predprobdata2$basenum %in% clustdf$mid[which(clustdf$medoid=="Yes")], "Yes", "No")

predicteddata2 <- predprobdata2[which(predprobdata2$predicted=="Yes"),]

ggplot() + 
  geom_line(data=predprobdata2, aes(x=basenum, y=prob), 
            color='black',
            size=.5)+
  geom_vline(data=calleddata, aes(xintercept=basenum, 
                                  color="blue"),
             size=.75,
             show.legend = TRUE)+
  geom_vline(data=predicteddata, aes(xintercept=basenum, 
                                     color="red"),
             size=.75,
             show.legend = TRUE)+
  geom_vline(data=predicteddata2, aes(xintercept=basenum, 
                                      color="green"),
             size=.75,
             show.legend = TRUE)+
  xlab("Base Pair") +
  ylab("Predicted Probability") +
  scale_color_manual(name = '', 
                     values =c("blue", "green", "red"),
                     labels = c("Called Boundary",
                                "Predicted Boundary",
                                "Predicted Region"))+
  theme_minimal() +
  theme_bw() +
  theme(axis.text.x = element_text(size=15),
        axis.text.y = element_text(size = 15),
        axis.title.x = element_text(size = 20),
        axis.title.y = element_text(size = 20),
        #strip.text.x = element_text(size = 15),
        #panel.spacing = unit(2, "lines"),
        legend.text=element_text(size=15),
        legend.title=element_text(size=20),
        plot.title = element_text(size=20),
        legend.position = "bottom")

```

